Newspeak3
'Benchmarks'
class ParserCombinators usingPlatform: p = (
(* A macrobenchmark based on the Newspeak's CombinatorialParsing. This benchmark parses and evaluates a fixed string with a simple arithmetic expression grammar. These parser combinators use explicitly initialized forward reference parsers rather than mirrors to handle the cycles in the productions. They also do not use of any platform streams to avoid API differences.

It was expected that the bottleneck would be the non-local returns, or rather their translation as exceptions in Java/Dart/JavaScript. AFAWK, Hotspot optimizes exceptions but DartVM and V8 do not, so we expected Hotspot to outperform the others. Instead, we find V8 as the strong leader, for reasons we do not understand.

This benchmark is derived from the Newspeak version of CombinatorialParsers, which is why the Cadence copyrights apply.

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2012 Cadence Design Systems, Inc.
Copyright 2013 Ryan Macnak
   
Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)|
List = p collections OrderedCollection.

seed ::= 16rCAFE.
parser = SimpleExpressionGrammar new start compress.
theExpression = randomExpression: 20.
|assert: [theExpression size = 41137] message: 'Generated expression of the wrong size'.
assert: [(parser parseWithContext: (ParserContext over: theExpression) ifError: [parseFailed]) = 31615] message: 'Expression evaluated to wrong value')
(
class AlternatingParser either: p or: q = CombinatorialParser (|
p ::= p.
q ::= q.
|)
('as yet unclassified'
public compress = (
	compressed ifTrue: [^self].
	compressed: true.
	p:: p compress.
	q:: q compress.
	^self
)
public parseWithContext: ctxt ifError: onError = (
	| pos = ctxt position. |
	^p parseWithContext: ctxt ifError: [ctxt position: pos. ^q parseWithContext: ctxt ifError: onError]
)) : ()
class CharacterRangeParser between: c1 and: c2 = CombinatorialParser (|
lowerBound = c1.
upperBound = c2.
|)
('as yet unclassified'
public compress = (
	^self
)
public parseWithContext: ctxt ifError: onError = (
	| c |
	ctxt atEnd ifTrue: [onError value].
	c:: ctxt next.
	(lowerBound <= c) & (c <= upperBound) ifTrue: [^c].
	onError value.
)) : ()
class CombinatorialParser = (|
compressed ::= false.
|)
('as yet unclassified'
public , p = (
	^SequencingParser subparsers: {self. p}
)
public char: c = (
	^CharacterRangeParser between: c and: c.
)
public charBetween: c1 and: c2 = (
	^CharacterRangeParser between: c1 and: c2.
)
public eoi = (
	^EOIParser new
)
public parseWithContext: ctxt ifError: onError = (
	subclassResponsibility
)
public star = (
	^StarParser repeat: self
)
public wrapper: block = (
	^WrappingParser wrap: self with: block
)
public | q = (
	^AlternatingParser either: self or: q
)) : ()
class EOIParser = CombinatorialParser ()
('as yet unclassified'
public compress = (
	^self
)
public parseWithContext: ctxt ifError: onError = (
	ctxt atEnd ifTrue: [^nil].
	onError value.
)) : ()
class ForwardReferenceParser = CombinatorialParser (|
forwardee
|)
('as yet unclassified'
public bind: p = (
	assert: [forwardee isNil] message: ''.
	forwardee:: p.
)
public compress = (
	^forwardee compress
)) : ()
class ParserContext over: s = (|
	content = s.
	public position ::= 0.
|)
('as yet unclassified'
public atEnd = (
	^position >= content size
)
public next = (
	position: position + 1.
	^content at: position
)) : ()
class SequencingParser subparsers: ps = CombinatorialParser (|
	subparsers ::= ps.
|)
('as yet unclassified'
public , p = (
	^SequencingParser subparsers: (subparsers copyWith: p)
)
public compress = (
	compressed ifTrue: [^self].
	compressed: true.
	subparsers:: subparsers collect: [:e | e compress].
	^self
)
public parseWithContext: ctxt ifError: onError = (
	^subparsers collect: [:p | p parseWithContext: ctxt ifError: onError]
)
public wrapper: block = (
	^WrappingParser wrap: self with: [:results | block valueWithArguments: results]
)) : ()
class SimpleExpressionGrammar = CombinatorialParser (|
public start = ForwardReferenceParser new.
exp = ForwardReferenceParser new.
e1 = ForwardReferenceParser new.
e2 = ForwardReferenceParser new.
parenExp = ForwardReferenceParser new.
number = ForwardReferenceParser new.
plus = ForwardReferenceParser new.
times = ForwardReferenceParser new.
digit = ForwardReferenceParser new.
lparen = ForwardReferenceParser new.
rparen = ForwardReferenceParser new.
|start bind: (exp, eoi wrapper: [:v :dollar | v]).
exp bind: (e1, (plus, e1) star wrapper: [:lhs :rhss | 
		| z ::= lhs. | rhss do: [:rhs | z:: z + (rhs at: 2) rem: 16rFFFF]. z]).
e1 bind: (e2, (times, e2) star wrapper: [:lhs :rhss | 
		| z ::= lhs. | rhss do: [:rhs | z:: z * (rhs at: 2) rem: 16rFFFF]. z]).
e2 bind: (number | parenExp).
	
parenExp bind: (lparen, exp, rparen wrapper: [:lhs :e :rhs | e]).
number bind: (digit wrapper: [:d | d asString asNumber]).
	
	plus bind: (char: $+).
	times bind: (char: $*).
	digit bind: (charBetween: $0 and: $9).
	lparen bind: (char: $().
	rparen bind: (char: $)))
() : ()
class StarParser repeat: p = CombinatorialParser (|
p ::= p.
|)
('as yet unclassified'
public compress = (
	compressed ifTrue: [^self].
	compressed: true.
	p:: p compress.
	^self
)
public parseWithContext: ctxt ifError: onError = (
	| results = List new. |
	[
		| pos = ctxt position. |
		results add: (p parseWithContext: ctxt ifError: [ctxt position: pos. ^results]).
	] repeat.
)
public wrapper: block = (
	^WrappingParser wrap: self with: [:results | block valueWithArguments: results]
)) : ()
class WrappingParser wrap: p with: b = CombinatorialParser (|
p ::= p.
b = b.
|)
('as yet unclassified'
public compress = (
	compressed ifTrue: [^self].
	compressed: true.
	p:: p compress.
	^self
)
public parseWithContext: ctxt ifError: onError = (
	^b value: (p parseWithContext: ctxt ifError: onError)
)) : ()'as yet unclassified'
public bench = (
	parser parseWithContext: (ParserContext over: theExpression) ifError: [parseFailed].
)
nextRandom = (
	seed:: seed * 16rDEAD + 16rC0DE.
	seed:: seed bitAnd: 16rFFF.
	^seed
)
randomExpression: depth = (
	| m |
	depth < 1 ifTrue: [^(nextRandom rem: 10) printString].
	m:: nextRandom rem: 3.
	m = 0 ifTrue: [^(randomExpression: depth-1),'+',(randomExpression: depth-1)].
	m = 1 ifTrue: [^(randomExpression: depth-1),'*',(randomExpression: depth-1)].
	m = 2 ifTrue: [^'(',(randomExpression: depth-1),')'].
	halt.
)) : ()