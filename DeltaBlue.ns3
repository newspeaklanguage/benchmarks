Newspeak3
'Benchmarks'
class DeltaBlue usingPlatform: p = (
"One-way constraint solver, originally written in Smalltalk by John Maloney and Mario Wolczko.

The factories of constraints have side effects, which is poor coding style but retained to keep to benchmark close to the original.

This code was derived by converting the Strongtalk version to Newspeak, which is why the Sun Microsystems copyright and BSD license below applies.

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
(c) 2012 Google Inc.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, 
 this  list of conditions and the following disclaimer.

* Redistribution in binary form must reproduce the above copyright notice, 
this list of conditions and the following disclaimer in the documentation and/o other materials provided with the distribution.

Neither the name of Sun Microsystems or the names of contributors may 
be used to endorse or promote products derived from this software without 
specific prior written permission.

>>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS 
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
DAMAGE.>>
"|
OrderedCollection = p collections OrderedCollection.
SortedCollection = p collections SortedCollection.
Dictionary = p collections Dictionary.
Interval  = p collections Interval.
Time = p time Time.

AbsoluteStrongest
AbsoluteWeakest
Required
StrengthConstants
StrengthTable
|Strength initialize)
(
class Plan = (
"A Plan is an ordered list of constraints to be executed in sequence to resatisfy all currently satisfiable constraints in the face of one or more changing inputs."|
	constraints = OrderedCollection new.
|)
('accessing'
size = (
	^constraints size
)'add/remove'
addLast: c <Constraint> = (
	constraints addLast: c.
)'execution'
execute = (
	"Execute my constraints in order."

	constraints do: [: c | c execute].
)) : ()
class Planner = (
"I embody the DeltaBlue algorithm described in:
	''The DeltaBlue Algorithm: An Incremental Constraint Hierarchy Solver''
	by Bjorn N. Freeman-Benson and John Maloney
See January 1990 Communications of the ACM or University of Washington TR 89-08-06 for further details."|
	currentMark ::= 1.
|)
(
class AbstractConstraint strength: strengthSymbol = (|
	strength ::= Strength of: strengthSymbol.
|)
('add/remove'
addConstraint = (
	"Activate this constraint and attempt to satisfy it."

	self addToGraph.
	incrementalAdd: self.
)
addToGraph = (
	"Add myself to the constraint graph."

	self subclassResponsibility
)
destroyConstraint = (
	"Deactivate this constraint, remove it from the constraint graph, possibly causing other constraints to be satisfied, and destroy it."

	(self isSatisfied) ifTrue: [incrementalRemove: self].
	self removeFromGraph.
)
removeFromGraph = (
	"Remove myself from the constraint graph."

	self subclassResponsibility
)'planning'
chooseMethod: mark = (
	"Decide if I can be satisfied and record that decision. The output of the choosen method must not have the given mark and must have a walkabout strength less than that of this constraint."

	self subclassResponsibility
)
execute = (
	"Enforce this constraint. Assume that it is satisfied."

	self subclassResponsibility
)
inputsDo: aBlock = (
	"Assume that I am satisfied. Evaluate the given block on all my current input variables."

	self subclassResponsibility
)
inputsKnown: mark = (
	"Assume that I am satisfied. Answer true if all my current inputs are known. A variable is known if either a) it is 'stay' (i.e. it is a constant at plan execution time), b) it has the given mark (indicating that it has been computed by a constraint appearing earlier in the plan), or c) it is not determined by any constraint."

	self inputsDo:
		[: v |
		 ((v mark = mark) or: [(v stay) or: [v determinedBy == nil]]) ifFalse:
			[^false]].
	^true
)
markUnsatisfied = (
	"Record the fact that I am unsatisfied."

	self subclassResponsibility
)
output = (
	"Answer my current output variable. Raise an error if I am not currently satisfied."

	self subclassResponsibility
)
recalculate = (
	"Calculate the walkabout strength, the stay flag, and, if it is 'stay', the value for the current output of this constraint. Assume this constraint is satisfied."

	self subclassResponsibility
)
satisfy: mark = (
	"Attempt to find a way to enforce this constraint. If successful, record the solution, perhaps modifying the current dataflow graph. Answer the constraint that this constraint overrides, if there is one, or nil, if there isn't."
	"Assume: I am not already satisfied"

	| overridden out |
	self chooseMethod: mark.
	(self isSatisfied)
		ifTrue:			"constraint can be satisfied"
			["mark inputs to allow cycle detection in addPropagate"
			 self inputsDo: [: in | in mark: mark].
			 out:: self output.
			 overridden:: out determinedBy.
			 (overridden == nil) ifFalse: [overridden markUnsatisfied].
			 out determinedBy: self.
			 (addPropagate: self mark: mark) ifFalse:
				[self notify:
					('Cycle encountered adding:\   ',
					 self printString,
					 '\Constraint removed.') withCRs.
				 ^nil].
			 out mark: mark]
		ifFalse:			"constraint cannot be satisfied"
			[overridden:: nil.
			 (strength sameAs: (Strength required)) ifTrue:
				[self notify: 'Failed to satisfy a required constraint']].
	^overridden
)'queries'
includeInPlan = (
	"Answer true if this constraint should be included in the plan. Subclasses such as EditConstraint and StayConstraint override this method to return 'false', since they are noops at plan execution time."

	^true
)
isInput = (
	"Normal constraints are not input constraints. An input constraint is one that depends on external state, such as the mouse, the keyboard, a clock, or some arbitrary piece of imperative code."

	^false
)
isSatisfied = (
	"Answer true if this constraint is satisfied in the current solution."

	self subclassResponsibility
)) : ()
class BinaryConstraint var: variable1 var: variable2 strength: strengthSymbol = AbstractConstraint strength: strengthSymbol (
"I am an abstract superclass for constraints having two possible output variables.

Instance variables:
	v1, v2		possible output variables <Variable>
	direction		one of:
					#forward (v2 is output)
					#backward (	v1 is output)
					nil (not satisfied)"|
	v1 ::= variable1.
	v2 ::= variable2.
	direction
|)
('add/remove'
addToGraph = (
	"Add myself to the constraint graph."

	v1 addConstraint: self.
	v2 addConstraint: self.
	direction:: nil.
)
removeFromGraph = (
	"Remove myself from the constraint graph."

	(v1 == nil) ifFalse: [v1 removeConstraint: self].
	(v2 == nil) ifFalse: [v2 removeConstraint: self].
	direction:: nil.
)'planning'
chooseMethod: mark = (
	"Decide if I can be satisfied and which way I should flow based on the relative strength of the variables I relate, and record that decision."

	(v1 mark == mark) ifTrue:		"forward or nothing"
		[((v2 mark = mark) not and: [strength stronger: v2 walkStrength])
			ifTrue: [^direction:: #forward]
			ifFalse: [^direction:: nil]].

	(v2 mark == mark) ifTrue:		"backward or nothing"
		[((v1 mark = mark) not and: [strength stronger: v1 walkStrength])
			ifTrue: [^direction:: #backward]
			ifFalse: [^direction:: nil]].

	"if we get here, neither variable is marked, so we have choice"
	(v1 walkStrength weaker: v2 walkStrength)
		ifTrue:
			[(strength stronger: v1 walkStrength)
				ifTrue: [^direction:: #backward]
				ifFalse: [^direction:: nil]]
		ifFalse:
			[(strength stronger: v2 walkStrength)
				ifTrue: [^direction:: #forward]
				ifFalse: [^direction:: nil]].
			
)
execute = (
	"Enforce this constraint. Assume that it is satisfied."

	self subclassResponsibility
)
inputsDo: aBlock = (
	"Evaluate the given block on my current input variable."

	(direction = #forward)
		ifTrue: [aBlock value: v1]
		ifFalse: [aBlock value: v2].
)
markUnsatisfied = (
	"Record the fact that I am unsatisfied."

	direction:: nil.
)
output = (
	"Answer my current output variable."

	(direction = #forward)
		ifTrue: [^v2]
		ifFalse: [^v1]
)
recalculate = (
	"Calculate the walkabout strength, the stay flag, and, if it is 'stay', the value for the current output of this constraint. Assume this constraint is satisfied."

	| in out |
	(direction = #forward)
		ifTrue: [in:: v1. out:: v2]
		ifFalse: [in:: v2. out:: v1].
	out walkStrength: (strength weakest: in walkStrength).
	out stay: (in stay).
	(out stay) ifTrue: [self execute].		"stay optimization"
)'queries'
isSatisfied = (
	"Answer true if this constraint is satisfied in the current solution."

	^direction notNil
)) : ()
class EditConstraint var: aVariable strength: strengthSymbol = UnaryConstraint var: aVariable strength: strengthSymbol (
"I am a unary input constraint used to mark a variable that the client wishes to change."self addConstraint)
('execution'
execute = (
	"Edit constraints do nothing."
)'queries'
includeInPlan = (
	"Edit constraints have no effect other than to control the planning process."

	^false
)
isInput = (
	"I indicate that a variable is to be changed by imperative code."

	^true
)) : ()
class EqualityConstraint var: variable1 var: variable2 strength: strengthSymbol = BinaryConstraint var: variable1 var: variable2 strength: strengthSymbol (
"I constrain two variables to have the same value: ''v1 = v2''."self addConstraint)
('execution'
execute = (
	"Enforce this constraint. Assume that it is satisfied."

	(direction = #forward)
		ifTrue: [v2 value: v1 value]
		ifFalse: [v1 value: v2 value].
)) : ()
class ScaleConstraint src: srcVar scale: scaleVar offset: offsetVar dst: dstVar strength: strengthSymbol = BinaryConstraint var: srcVar var: dstVar strength: strengthSymbol (
"I relate two variables by the linear scaling relationship: ''v2 = (v1 * scale) + offset''. Either v1 or v2 may be changed to maintain this relationship but the scale factor and offset are considered read-only.

Instance variables:
	scale		scale factor input variable <Variable>
	offset		offset input variable <Variable>"|
	scale ::= scaleVar.
	offset ::= offsetVar.
|self addConstraint)
('add/remove'
addToGraph = (
	"Add myself to the constraint graph."

	v1 addConstraint: self.
	v2 addConstraint: self.
	scale addConstraint: self.
	offset addConstraint: self.
	direction:: nil.
)
removeFromGraph = (
	"Remove myself from the constraint graph."

	(v1 == nil) ifFalse: [v1 removeConstraint: self].
	(v2 == nil) ifFalse: [v2 removeConstraint: self].
	(scale == nil) ifFalse: [scale removeConstraint: self].
	(offset == nil) ifFalse: [offset removeConstraint: self].
	direction:: nil.
)'planning'
execute = (
	"Enforce this constraint. Assume that it is satisfied."

	(direction = #forward)
		ifTrue: [v2 value: (v1 value * scale value) + offset value]
		ifFalse: [v1 value: (v2 value - offset value) // scale value].
)
inputsDo: aBlock = (
	"Evaluate the given block on my current input variable."

	(direction = #forward)
		ifTrue: [aBlock value: v1; value: scale; value: offset]
		ifFalse: [aBlock value: v2; value: scale; value: offset].
)
recalculate = (
	"Calculate the walkabout strength, the stay flag, and, if it is 'stay', the value for the current output of this constraint. Assume this constraint is satisfied."

	| in out |
	(direction = #forward)
		ifTrue: [in:: v1. out:: v2]
		ifFalse: [out:: v1. in:: v2].
	out walkStrength: (strength weakest: in walkStrength).
	out stay: ((in stay) and: [(scale stay) and: [offset stay]]).
	(out stay) ifTrue: [self execute].		"stay optimization"
)) : ()
class StayConstraint var: aVariable strength: strengthSymbol = UnaryConstraint var: aVariable strength: strengthSymbol (
"I mark variables that should, with some level of preference, stay the same. I have one method with zero inputs and one output, which does nothing. Planners may exploit the fact that, if I am satisfied, my output will not change during plan execution. This is called ''stay optimization.''"self addConstraint)
('execution'
execute = (
	"Stay constraints do nothing."
)'queries'
includeInPlan = (
	"Stay constraints have no effect other than to control the planning process."

	^false
)) : ()
class UnaryConstraint var: aVariable strength: strengthSymbol = AbstractConstraint strength: strengthSymbol (
"I am an abstract superclass for constraints having a single possible output variable.

Instance variables:
	output		possible output variable <Variable>
	satisfied		true if I am currently satisfied <Boolean>"|
output ::= aVariable.
satisfied ::= false.
|)
('add/remove'
addToGraph = (
	"Add myself to the constraint graph."

	output addConstraint: self.
	satisfied:: false.
)
removeFromGraph = (
	"Remove myself from the constraint graph."

	(output == nil) ifFalse: [output removeConstraint: self].
	satisfied:: false.
)'planning'
chooseMethod: mark = (
	"Decide if I can be satisfied and record that decision."

	satisfied::
		(output mark = mark) not and:
		[strength stronger: output walkStrength].
)
execute = (
	"Enforce this constraint. Assume that it is satisfied."

	self subclassResponsibility
)
inputsDo: aBlock = (
	"I have no input variables."
)
markUnsatisfied = (
	"Record the fact that I am unsatisfied."

	satisfied:: false.
)
recalculate = (
	"Calculate the walkabout strength, the stay flag, and, if it is 'stay', the value for the current output of this constraint. Assume this constraint is satisfied."

	output walkStrength: strength.
	output stay: (self isInput not).
	(output stay) ifTrue: [self execute].	"stay optimization"
)'queries'
isSatisfied = (
	"Answer true if this constraint is satisfied in the current solution."

	^satisfied
)) : ()
class Variable = (
"I represent a constrained variable. In addition to my value, I maintain the structure of the constraint graph, the current dataflow graph, and various parameters of interest to the DeltaBlue incremental constraint solver.

Instance variables:
	value			my value; changed by constraints, read by client <Object>
	constraints		normal constraints that reference me <Array of Constraint>
	determinedBy	the constraint that currently determines
					my value (or nil if there isn't one) <Constraint>
	walkStrength		my walkabout strength <Strength>
	stay			true if I am a planning-time constant <Boolean>
	mark			used by the planner to mark constraints <Number>"|
value ::= 0.
constraints ::= OrderedCollection new: 2.
determinedBy
walkStrength ::= Strength absoluteWeakest.
stay ::= true.
mark ::= 0.
|)
('access'
addConstraint: aConstraint = (
	"Add the given constraint to the set of all constraints that refer to me."

	constraints add: aConstraint.
)
removeConstraint: c = (
	"Remove all traces of c from this variable."

	constraints remove: c ifAbsent: [].
	(determinedBy == c) ifTrue: [determinedBy:: nil].
)'changes'
changeIn: aBlock strength: strengthSymbol = (
	"Attempt to add an edit constraint of the given strength to myself and execute the given block only if this constraint can be satisfied (i.e. no stronger constraint prevents me from changing)."

	| editConstraint |
	editConstraint:: EditConstraint var: self strength: strengthSymbol.
	(editConstraint isSatisfied) ifTrue:
		[aBlock value.
		 Planner propagateFrom: self].
	editConstraint destroyConstraint.
)
setAll: variables to: values strength: strengthSymbol = (
	"Attempt to assign the given values to the given variables using the given strength. This is an all-or-nothing operation; if any variable cannot be changed due to a stronger constraint then no variable is changed."

	| allSatisfied editConstraints editConstraint |
	(variables size = values size) ifFalse:
		[^self error: 'variable and value lists must be same size'].

	"add edit constraints"
	allSatisfied:: true.		"true iff all edit constraints are satisfied"
	editConstraints:: variables collect:
		[: v |
		 editConstraint:: EditConstraint var: v strength: strengthSymbol.
		 (editConstraint isSatisfied) ifFalse: [allSatisfied:: false].
		 editConstraint].

	(allSatisfied) ifTrue:
		["do the assignments only if all edit constraints are satisfied"
		 variables with: values do:
			[:thisVar :thisValue |
			 thisVar value: thisValue.
			 Planner propagateFrom: thisVar]].

	"remove edit constraints"
	editConstraints do: [:c | c destroyConstraint].
)
setValue: aValue = (
	"Attempt to assign the given value to me using a strength of #preferred."

	self setValue: aValue strength: #preferred.
)
setValue: aValue strength: strengthSymbol = (
	"Attempt to assign the given value to me using the given strength."

	| editConstraint |
	editConstraint:: EditConstraint var: self strength: strengthSymbol.
	(editConstraint isSatisfied) ifTrue:
		[self value: aValue.
		 propagateFrom: self].
	editConstraint destroyConstraint.
)'equality constraints'
requireEquals: aVariable = (
	"Install a required equality constraint between me and the given variable."

	^EqualityConstraint var: self var: aVariable strength: #required
)'stay constraints'
defaultStay = (

	^StayConstraint var: self strength: #default
)
preferredStay = (

	^StayConstraint var: self strength: #preferred
)
requiredStay = (

	^StayConstraint var: self strength: #required
)
strongDefaultStay = (

	^StayConstraint var: self strength: #strongDefault
)
strongPreferredStay = (

	^StayConstraint var: self strength: #strongPreferred
)
weakDefaultStay = (

	^StayConstraint var: self strength: #weakDefault
)) : ('instance creation'
value: aValue = (

	^self new value: aValue
))'add/remove'
incrementalAdd: c = (
	"Attempt to satisfy the given constraint and, if successful, incrementally update the dataflow graph."
	"Details: If satifying the constraint is successful, it may override a weaker constraint on its output. The algorithm attempts to resatisfy that constraint using some other method. This process is repeated until either a) it reaches a variable that was not previously determined by any constraint or b) it reaches a constraint that is too weak to be satisfied using any of its methods. The variables of constraints that have been processed are marked with a unique mark value so that we know where we've been. This allows the algorithm to avoid getting into an infinite loop even if the constraint graph has an inadvertent cycle."

	| mark overridden |
	mark:: self newMark.
	overridden:: c satisfy: mark.
	[overridden == nil] whileFalse:
		[overridden:: overridden satisfy: mark].
)
incrementalRemove: c = (
	"Entry point for retracting a constraint. Remove the given constraint and incrementally update the dataflow graph."
	"Details: Retracting the given constraint may allow some currently unsatisfiable downstream constraint be satisfied. We thus collect a list of unsatisfied downstream constraints and attempt to satisfy each one in turn. This list is sorted by constraint strength, strongest first, as a heuristic for avoiding unnecessarily adding and then overriding weak constraints."
	"Assume: c is satisfied."

	| out unsatisfied |
	out:: c output.
	c markUnsatisfied.
	c removeFromGraph.
	unsatisfied:: self removePropagateFrom: out.
	unsatisfied do: [: u | self incrementalAdd: u].
)'benchmarks'
chainTest: n = (
	"Do chain-of-equality-constraints performance tests"

	| equalsC vars constraints v1 v2 eqC editConstraint plan |
	self report: 'Built chain of ', n printString, ' equality constraints in' times: 1 run:
		[vars:: (Interval from: 0 to: n) collect: [: i | Variable new].
		 constraints:: OrderedCollection new: n.
		 "thread a chain of equality constraints through the variables"
		 1 to: n do:
			[: i |
			 v1:: (vars at: i).
			 v2:: (vars at: i + 1).
			 eqC:: v1 requireEquals: v2 "equalsC copy var: v1 var: v2 strength: #required".
			 constraints add: eqC].
		 vars last strongDefaultStay].

	self report: 'Add constraint (case 1):' times: 1 run:
		[editConstraint:: EditConstraint var: (vars first) strength: #preferred].
	self report: 'Make Plan (case 1)' times: 1 run:
		[plan:: self extractPlanFromConstraints: (Array with: editConstraint)].
	"Transcript show: 'Plan length: ', plan size printString, ' constraints'; cr."
	self report: 'Execute Plan (case 1):' times: 20 run:
		[plan execute].
	self report: 'Remove constraint (case 1):' times: 1 run:
		[editConstraint destroyConstraint].
	self report: 'Setting first node: (case 1a):' times: 1 run:
		[(vars first) setValue: 123 strength: #strongPreferred].
	self report: 'Setting last node: (case 1b):' times: 1 run:
		[(vars last) setValue: 321 strength: #strongPreferred].
	"Transcript cr."

	self report: 'Add constraint (case 2):' times: 1 run:
		[editConstraint:: EditConstraint var: (vars first) strength: #default].
	self report: 'Make Plan (case 2):' times: 1 run:
		[plan:: self extractPlanFromConstraints: (Array with: editConstraint)].
	"Transcript show: 'Plan length: ', plan size printString, ' constraints'; cr."
	self report: 'Execute Plan (case 2):' times: 20 run:
		[plan execute].
	self report: 'Remove constraint (case 2):' times: 1 run:
		[editConstraint destroyConstraint].
	self report: 'Setting first node: (case 2a):' times: 1 run:
		[(vars first) setValue: 1230 strength: #weakDefault].
	self report: 'Setting last node: (case 2b):' times: 1 run:
		[(vars last) setValue: 3210 strength: #weakDefault].
	"Transcript cr."

	"Transcript cr."
)
projectionTest: n = (
"This test constructs a two sets of variables related to each other by a simple linear transformation (scale and offset). The time is measured to change a variable on either side of the mapping and to change the scale and offset factors. Results are printed in the Transcript."
	"Planner projectionTest: 100"

	| projectionC constraints scale offset src dst |
	constraints:: OrderedCollection new.

	self report: 'Projection test for ', n printString, ' points (Smalltalk):' times: 1 run:
		[scale:: Variable value: 10.
		 offset:: Variable value: 1000.
		 1 to: n do:
			[: i |
			 src:: Variable value: i.
			 dst:: Variable value: i.
			 constraints add: (src defaultStay).
			 constraints add:
				(ScaleConstraint
					src: src scale: scale offset: offset dst: dst
					strength: #required)]].
	self reportChange: 'Changing a data point:'
		var: src newValue: 17.
dst value = 1170 ifFalse: [projection1Failed].		
	self reportChange: 'Changing a projected point:'
		var: dst newValue: 1050.
src value = 5 ifFalse: [proj2failed].		
	self reportChange: 'Changing the scale factor:'
		var: scale newValue: 5.
		
	self reportChange: 'Changing the offset:'
		var: offset newValue: 2000.

	"Transcript cr."
)
report: string times: count run: aBlock = (

	count timesRepeat: aBlock

	"Report the time required to execute the given block."

	"| time |
	time:: Time millisecondsToRun: [count timesRepeat: aBlock].
	Transcript show: string, ' ', (time // count) printString, ' milliseconds'; cr."
)
reportChange: title var: aVariable newValue: newValue = (

	| editConstraint plan |
	"Transcript show: title; cr."
	self report: '  Adding Constraint:' times: 1 run:
		[editConstraint:: EditConstraint var: aVariable strength: #preferred].
	self report: '  Making Plan' times: 1 run:
		[plan:: extractPlanFromConstraints: (Array with: editConstraint)].
	"Transcript show: '  Plan size: ', plan size printString, ' constraints'; cr."
	self report: '  Executing Plan:' times: 10 run:
		[aVariable value: newValue. plan execute].
	self report: '  Removing Constraint:' times: 1 run:
		[editConstraint destroyConstraint].
)'planning/value propagation'
extractPlanFromConstraints: constraints = (
	"Extract a plan for resatisfaction starting from the outputs of the given constraints, usually a set of input constraints."

	| sources |
	sources:: OrderedCollection new.
	constraints do:
		[: c | ((c isInput) and: [c isSatisfied]) ifTrue: [sources add: c]].
	^self makePlan: sources
)
extractPlanFromVariables: variables = (
	"Extract a plan from the dataflow graph having the given variables. It is assumed that the given set of variables is complete, or at least that it contains all the input variables."

	| sources |
	sources:: OrderedCollection new.
	variables do:
		[: v |
		 (v constraints) do:
			[: c | ((c isInput) and: [c isSatisfied]) ifTrue: [sources add: c]]].
	^self makePlan: sources
)
makePlan: sources = (
	"Extract a plan for resatisfaction starting from the given source constraints, usually a set of input constraints. This method assumes that stay optimization is desired; the plan will contain only constraints whose output variables are not stay. Constraints that do no computation, such as stay and edit constraints, are not included in the plan."
	"Details: The outputs of a constraint are marked when it is added to the plan under construction. A constraint may be appended to the plan when all its input variables are known. A variable is known if either a) the variable is marked (indicating that has been computed by a constraint appearing earlier in the plan), b) the variable is 'stay' (i.e. it is a constant at plan execution time), or c) the variable is not determined by any constraint. The last provision is for past states of history variables, which are not stay but which are also not computed by any constraint."
	"Assume: sources are all satisfied."

	| mark plan todo c |
	mark:: self newMark.
	plan:: Plan new.
	todo:: sources.
	[todo isEmpty] whileFalse:
		[c:: todo removeFirst.
		 ((c output mark = mark) not and:		"not in plan already and..."
		  [c inputsKnown: mark]) ifTrue:		"eligible for inclusion"
			[plan addLast: c.
			 c output mark: mark.
			 c:: self addConstraintsConsuming: c output to: todo]].
	^plan
)
propagateFrom: v = (
	"The given variable has changed. Propagate new values downstream."

	| todo c |
	todo:: OrderedCollection new.
	self addConstraintsConsuming: v to: todo.
	[todo isEmpty] whileFalse:
		[c:: todo removeFirst.
		 c execute.
		 self addConstraintsConsuming: c output to: todo].
)'private'
addConstraintsConsuming: v to: aCollection = (

	| determiningC |
	determiningC:: v determinedBy.
	v constraints do:
		[: c |
		 ((c == determiningC) or: [c isSatisfied not]) ifFalse:
			[aCollection add: c]].
)
addPropagate: c mark: mark = (
	"Recompute the walkabout strengths and stay flags of all variables downstream of the given constraint and recompute the actual values of all variables whose stay flag is true. If a cycle is detected, remove the given constraint and answer false. Otherwise, answer true."
	"Details: Cycles are detected when a marked variable is encountered downstream of the given constraint. The sender is assumed to have marked the inputs of the given constraint with the given mark. Thus, encountering a marked node downstream of the output constraint means that there is a path from the constraint's output to one of its inputs."

	| todo d |
	todo:: OrderedCollection with: c.
	[todo isEmpty] whileFalse:
		[d:: todo removeFirst.
		 (d output mark = mark) ifTrue:
			[self incrementalRemove: c.
			 ^false].
		 d recalculate.
		 self addConstraintsConsuming: d output to: todo].
	^true
)
constraintsConsuming: v do: aBlock = (

	| determiningC |
	determiningC:: v determinedBy.
	v constraints do:
		[: c |
		 ((c == determiningC) or: [c isSatisfied not]) ifFalse:
			[aBlock value: c]].
)
newMark = (
	"Select a previously unused mark value."
	"Details: We just keep incrementing. If necessary, the counter will turn into a LargePositiveInteger. In that case, it will be a bit slower to compute the next mark but the algorithms will all behave correctly. We reserve the value '0' to mean 'unmarked'. Thus, this generator starts at '1' and will never produce '0' as a mark value."

	^currentMark:: currentMark + 1
)
removePropagateFrom: out = (
	"Update the walkabout strengths and stay flags of all variables downstream of the given constraint. Answer a collection of unsatisfied constraints sorted in order of decreasing strength."

	| unsatisfied todo v nextC |
	unsatisfied:: SortedCollection sortBlock:
		[: c1 : c2 | c1 strength stronger: c2 strength].
	out determinedBy: nil.
	out walkStrength: Strength absoluteWeakest.
	out stay: true.
	todo:: OrderedCollection with: out.
	[todo isEmpty] whileFalse:
		[v:: todo removeFirst.
		 v constraints do:
		 	[: c | (c isSatisfied) ifFalse: [unsatisfied add: c]].
		 self constraintsConsuming: v do:
			[: c |
			 c recalculate.
			 todo add: c output]].
	^unsatisfied
)) : ()
class Strength = (
"Strengths are used to measure the relative importance of constraints. The hierarchy of available strengths is determined by the class variable StrengthTable (see my class initialization method). Because Strengths are invariant, references to Strength instances are shared (i.e. all references to ''Strength of: #required'' point to a single, shared instance). New strengths may be inserted in the strength hierarchy without disrupting current constraints.

Instance variables:
	symbolicValue		symbolic strength name (e.g. #required) <Symbol>
	arithmeticValue		index of the constraint in the hierarchy, used for comparisons <Number>"|
symbolicValue arithmeticValue	
|)
('comparing'
sameAs: aStrength = (
	"Answer true if I am the same strength as the given Strength."

	^arithmeticValue = aStrength arithmeticValue
)
stronger: aStrength = (
	"Answer true if I am stronger than the given Strength."

	^arithmeticValue < aStrength arithmeticValue
)
weaker: aStrength = (
	"Answer true if I am weaker than the given Strength."

	^arithmeticValue > aStrength arithmeticValue
)'max/min'
strongest: aStrength = (
	"Answer the stronger of myself and aStrength."

	(aStrength stronger: self)
		ifTrue: [^aStrength]
		ifFalse: [^self].
)
weakest: aStrength = (
	"Answer the weaker of myself and aStrength."

	(aStrength weaker: self)
		ifTrue: [^aStrength]
		ifFalse: [^self].
)'printing'
printOn: aStream = (
	"Append a string which represents my strength onto aStream."

	aStream nextPutAll: '%', symbolicValue, '%'.
)'private'
initializeWith: symVal = (
	"Record my symbolic value and reset my arithmetic value."

	symbolicValue:: symVal.
	self resetValue.
)
resetValue = (
	"Lookup my symbolic value in the StrengthTable and reset my internal value."

	arithmeticValue:: StrengthTable at: symbolicValue.
)) : ('class initialization'
initialize = (
	"Initialize the symbolic strength table. Fix the internally caches values of all existing instances."
	"Strength initialize"

	StrengthTable:: Dictionary new.
	StrengthTable at: #absoluteStrongest put: -1000.
	StrengthTable at: #required put: 0.
	StrengthTable at: #strongPreferred put: 1.
	StrengthTable at: #preferred put: 2.
	StrengthTable at: #strongDefault put: 3.
	StrengthTable at: #default put: 4.
	StrengthTable at: #weakDefault put: 5.
	StrengthTable at: #absoluteWeakest put: 1000.

	StrengthConstants:: Dictionary new.
	StrengthTable keys do:
		[: strengthSymbol |
			StrengthConstants
				at: strengthSymbol
				put: ((new) initializeWith: strengthSymbol)].

	"Fix arithmetic values stored in all instances."
"	Strength allInstancesDo:
		[: strength | strength resetValue].
"
	AbsoluteStrongest:: Strength of: #absoluteStrongest.
	AbsoluteWeakest:: Strength of: #absoluteWeakest.
	Required:: Strength of: #required.
)'constants'
absoluteStrongest = (

	^AbsoluteStrongest
)
absoluteWeakest = (

	^AbsoluteWeakest
)
required = (

	^Required
)'instance creation'
of: aSymbol = (
	"Answer an instance with the specified strength."

	^StrengthConstants at: aSymbol
))'as yet unclassified'
bench = (
	| planner = Planner new. |
	planner chainTest: 100.
	planner projectionTest: 100.
)) : ()